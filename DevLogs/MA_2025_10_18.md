# 今日进展
- 解决了玩家与墙面碰撞会卡手的问题：修改rigidbody的参数，并添加了物理材质No Friction。
- 解决了摄像机视角透视的问题：将相机的z轴向后即可
- 生成了能量光柱，并且用BeamGlow实现闪烁效果
```
using UnityEngine;

public class BeamGlow : MonoBehaviour
{
    public Renderer rend;
    public float glowSpeed = 2f;
    public Color baseColor = Color.cyan;

    void Start()
    {
        if (rend == null) rend = GetComponent<Renderer>();
    }

    void Update()
    {
        float emission = Mathf.PingPong(Time.time * glowSpeed, 1.0f);
        Color finalColor = baseColor * Mathf.LinearToGammaSpace(emission + 0.3f);
        rend.material.SetColor("_EmissionColor", finalColor);
    }
}
```
- 添加了BGM，并实现多曲目循环播放功能脚本。
```
using UnityEngine;

[RequireComponent(typeof(AudioSource))]
public class BGMMulti : MonoBehaviour
{
    public AudioClip[] clips;       // 放所有 BGM
    public float volume = 0.3f;

    private AudioSource audioSource;
    private int currentIndex = 0;

    void Start()
    {
        audioSource = GetComponent<AudioSource>();
        audioSource.volume = volume;
        audioSource.loop = false;   // 我们用脚本控制循环
        PlayNext();
    }

    void Update()
    {
        if (!audioSource.isPlaying)
        {
            PlayNext();
        }
    }

    void PlayNext()
    {
        if (clips.Length == 0) return;

        audioSource.clip = clips[currentIndex];
        audioSource.Play();

        currentIndex++;
        if (currentIndex >= clips.Length)
            currentIndex = 0; // 循环播放
    }
}

```
- 添加ESC退出游戏功能
```
          // 2️⃣ 等待几秒显示胜利界面
        yield return new WaitForSeconds(waitBeforeExit);

        // 3️⃣ 退出游戏（区分编辑器和打包后）
#if UNITY_EDITOR
        UnityEditor.EditorApplication.isPlaying = false; // 在编辑器中停止运行
#else
        Application.Quit(); // 在打包后的游戏中退出
#endif
    }
  ```
- 出现大问题，unity里面鼠标旋转和打包后的鼠标旋转效果不一致，两个中必有一个会出现卡顿抽帧，目前还未解决，只能勉强打包后运行，修改了FPSController代码。
- 目前询问出问题可能是“开发环境” 与 “运行环境” 的底层特性不同导致的：编辑器为了调试便捷牺牲了部分运行效率，且帧率、输入处理、物理同步逻辑与打包后的纯运行环境存在天然差异。这些差异最终通过 “时间步长”“输入采样”“响应延迟” 等环节，体现为灵敏度的主观感受不同。
- 1. 帧率差异导致的 “时间步长” 影响（最核心原因）：编辑器帧率通常远高于打包后
- 2. 输入处理的环境差异：输入采样与平滑的隐性区别
- 3. 物理更新与渲染帧的同步差异：FixedUpdate 与 Update 的调用比例不同
- 4. 编辑器运行时的额外开销
```
using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class FPSPlayerController : MonoBehaviour
{
    [Header("移动设置")]
    public float moveSpeed = 3f;
    [Tooltip("每秒旋转的角度（而非每帧），统一灵敏度基准")]
    public float lookAnglePerSecond = 120f; // 关键：改用“每秒角度”定义灵敏度
    [Range(0.1f, 1f)] public float rotateSmooth = 0.8f;

    [Header("相机设置")]
    public Transform playerCamera;
    public float minLookAngle = -60f;
    public float maxLookAngle = 40f;

    private Rigidbody rb;
    private float xRotation = 0f;
    private float mouseXAccumulator;        // 累积鼠标X增量
    private float targetYaw;                // 目标水平旋转角度

    void Start()
    {
        rb = GetComponent<Rigidbody>();
        rb.constraints = RigidbodyConstraints.FreezeRotation;
        rb.interpolation = RigidbodyInterpolation.Interpolate;

        if (playerCamera == null)
            playerCamera = Camera.main.transform;

        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;

        targetYaw = transform.eulerAngles.y;
    }

    void Update()
    {
        // 1. 鼠标输入采用原始值（减少不同环境下的平滑差异）
        float mouseX = Input.GetAxisRaw("Mouse X");
        float mouseY = Input.GetAxisRaw("Mouse Y");

        // 2. 垂直旋转：基于“每秒角度”计算，不受帧率影响
        float verticalRotateDelta = mouseY * lookAnglePerSecond * Time.deltaTime;
        xRotation = Mathf.Lerp(xRotation, xRotation - verticalRotateDelta, rotateSmooth * 10f);
        xRotation = Mathf.Clamp(xRotation, minLookAngle, maxLookAngle);
        playerCamera.localRotation = Quaternion.Euler(xRotation, 0f, 0f);

        // 3. 水平旋转增量累积（同样基于每秒角度）
        mouseXAccumulator += mouseX * lookAnglePerSecond * Time.deltaTime;

        CheckQuit();
    }

    void FixedUpdate()
    {
        HandleMovement();
        HandleHorizontalRotation();
    }

    void HandleHorizontalRotation()
    {
        if (Mathf.Abs(mouseXAccumulator) > 0.001f)
        {
            targetYaw += mouseXAccumulator;
            // 平滑旋转，确保物理与渲染同步
            float currentYaw = transform.eulerAngles.y;
            float smoothedYaw = Mathf.LerpAngle(currentYaw, targetYaw, rotateSmooth);
            rb.MoveRotation(Quaternion.Euler(0f, smoothedYaw, 0f));

            mouseXAccumulator = 0;
        }
    }

    void HandleMovement()
    {
        float horizontal = Input.GetAxis("Horizontal");
        float vertical = Input.GetAxis("Vertical");

        Vector3 moveDir = transform.forward * vertical + transform.right * horizontal;
        if (moveDir.magnitude > 1f) moveDir.Normalize();

        Vector3 targetVelocity = moveDir * moveSpeed;
        targetVelocity.y = rb.velocity.y;
        rb.velocity = Vector3.Lerp(rb.velocity, targetVelocity, rotateSmooth * 5f);
    }

    void CheckQuit()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            QuitGame();
        }
    }

    void QuitGame()
    {
        Debug.Log("退出游戏...");
#if UNITY_EDITOR
        UnityEditor.EditorApplication.isPlaying = false;
#else
        Application.Quit();
#endif
    }
}
```

# 明日计划
- 研究肉鸽游戏制作