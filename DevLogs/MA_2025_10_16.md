# 今日进展
- 修改了天空盒材质：Windows - Rendering - Lighting
- 运用BFS寻找并设立终点`SpawnExit();` 
```
//BFS函数
(Vector2Int farthestCell, int distance) FindFarthestCell()
{
    Queue<Vector2Int> q = new Queue<Vector2Int>();
    bool[,] visited = new bool[width, height];
    int[,] dist = new int[width, height];

    q.Enqueue(new Vector2Int(1, 1));
    visited[1, 1] = true;
    dist[1, 1] = 0;

    Vector2Int farthest = new Vector2Int(1, 1);

    while (q.Count > 0)
    {
        var cur = q.Dequeue();
        int x = cur.x, y = cur.y;

        foreach (var d in new (int, int)[] { (1, 0), (-1, 0), (0, 1), (0, -1) })
        {
            int nx = x + d.Item1;
            int ny = y + d.Item2;

            if (nx > 0 && nx < width && ny > 0 && ny < height && !visited[nx, ny] && maze[nx, ny] == 0)
            {
                visited[nx, ny] = true;
                dist[nx, ny] = dist[x, y] + 1;
                q.Enqueue(new Vector2Int(nx, ny));

                if (dist[nx, ny] > dist[farthest.x, farthest.y])
                    farthest = new Vector2Int(nx, ny);
            }
        }
    }
    return (farthest, dist[farthest.x, farthest.y]);
}

//生成出口
void SpawnExit()
{
    if (exitPrefab == null)
    {
        Debug.LogWarning("未设置出口预制体（exitPrefab）");
        return;
    }

    var (exitCell, distance) = FindFarthestCell();
    float offset = 0.01f;
    float heightOffset = exitPrefab.transform.localScale.y / 2f;

    Vector3 pos = new Vector3(exitCell.x + offset, heightOffset, exitCell.y + offset);
    Instantiate(exitPrefab, pos, Quaternion.identity, mazeParent.transform);

    Debug.Log($"出口位置：({exitCell.x},{exitCell.y})，距离起点 {distance}");
}
```
- 利用Trigger实现交互达成通关
```
using UnityEngine;

public class ExitTrigger : MonoBehaviour
{
    [Tooltip("玩家靠近时提示的按键")]
    public KeyCode interactKey = KeyCode.E;

    private bool playerInside = false;

//判断物体是否触碰到
    void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            playerInside = true;
        }
    }

    void OnTriggerExit(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            playerInside = false;
        }
    }

    void Update()
    {
        if (playerInside && Input.GetKeyDown(interactKey))
        {
            Debug.Log("到达出口！游戏结束！");
            // 这里可以加入UI提示、场景切换、游戏结算等
        }
    }

//有问题
    void OnGUI()
    {
        if (playerInside)
        {
            GUI.Label(new Rect(Screen.width / 2 - 60, Screen.height / 2 + 30, 200, 40), "按 E 互动（离开迷宫）");
        }
    }
}

```
- 修复了playerPrefab的脚本bug：之前一直挂空，只是因为场景中物体刚好在[1,1]导致能运行，实则该段程序无作用，改为直接用场景中物体
```
   //玩家生成
   void SpawnPlayer()
   {
       if (player == null)
       {
           Debug.LogWarning("请在 Inspector 中指定 Player 对象");
           return;
       }

       int startX = 1;
       int startY = 1;

       if (maze[startX, startY] != 0)
       {
           Debug.LogWarning("[1,1] 不是空格，无法生成玩家");
           return;
       }

       // 获取 Cube 高度（scale.y）并计算 Y 坐标
       float cubeHeight = player.transform.localScale.y;
       float cubeHalfHeight = cubeHeight / 2f;

       // X/Z 偏移，避免卡墙
       float offset = 0.01f;

       // 设置玩家位置
       Vector3 startPos = new Vector3(startX + offset, cubeHalfHeight, startY + offset);
       player.transform.position = startPos;
   }
```


# 明日计划
- 修改通关点材质，实现光柱效果
- 修改交互结果，生成UI或者动画
